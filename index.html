<!DOCTYPE html>
<html >
<head >
    <meta charset='utf-8' >

    <link rel="stylesheet" type="text/css" href="stylesheets/pygment_trac.css" media="screen" />

    <script type="text/javascript" language="JavaScript" src="http://code.jquery.com/jquery-1.7.2.min.js"></script>
    <script type="text/javascript" language="JavaScript" src="http://underscorejs.org/underscore-min.js"></script>
    <script type="text/javascript" language="JavaScript" src="http://backbonejs.org/backbone-min.js"></script>
    <script type="text/javascript" src="javascripts/SyntaxHighlighter/XRegExp.js"></script> <!-- XRegExp is bundled with the final shCore.js during build -->
    <script type="text/javascript" src="javascripts/SyntaxHighlighter/shCore.js"></script>
    <script type="text/javascript" src="javascripts/SyntaxHighlighter/shAutoloader.js"></script>
    <script src="javascripts/backbone-mvc.js" type="text/javascript" language="JavaScript"></script>
    <script src="javascripts/main.js" type="text/javascript" language="JavaScript"></script>

    <link type="text/css" rel="stylesheet" href="stylesheets/SyntaxHighlighter/shCoreRDark.css"/>
    <link type="text/css" rel="Stylesheet" href="stylesheets/SyntaxHighlighter/shThemeRDark.css" />
    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen" />
    <!--<link rel="stylesheet" type="text/css" href="stylesheets/print.css" media="print" />-->

    <title >Backskin : Add Controllers to Backbone.js</title >
</head >

<body >

<header >
    <div class="container" >
        <h1 >Backskin</h1 >

        <h2 ></h2 >

        <section id="downloads" >
            <a href="https://raw.github.com/chance-an/backskin/master/backbone-mvc.js" class="btn" >Download
                backbone-mvc.js</a >
            <a href="https://github.com/chance-an/backskin" class="btn btn-github" ><span class="icon" ></span >View on
                GitHub</a >
        </section >
    </div >
</header >

<div class="container" >
    <section id="main_content" >
        <section class="chapter" >
            <p >Backskin adds the missing Controller components into your project if you also use
                <a href="http://github.com/documentcloud/backbone/" >Backbone.js</a >, so now you have a complete MVC
                framework. Like
                <a href="http://cakephp.org/" >CakePHP</a >, it automatically routes your urls to the correct controller
                and its actions, but it is a framework for the web front end.
            </p >
        </section >

        <section class="chapter" >
            <h3 >Introduction</h3 >

            <p >Backbone.js does an excellent job of keeping data in sync between the HTML UI and your Javascript logic.
                However the difficulties we face when
                we build Javascript web applications are not completely addressed by Backbone.js . Sometimes the difficulty of
                efficiently organizing the Javascript logic itself is prominent. Using urls to lead the execution of the Javascript logic
                is a good way to implement your business logic. The browsers' assumption of a traditional server/client
                model is not compromised, so the browsers' basic functions can be preserved. It also helps resume the correct
                stage in your business flow from a stateless page.
            <p>Backbone.js provides
                <a href="http://backbonejs.org/#Router">Router</a> component to map an url to a function.
                It becomes cumbersome when the application is divided into many modules and there are many operations to
                be mapped for different urls. Besides, due to the limitations of the language itself, it is not easy to
                share common processes(like pre-processors and post-processors) among those operations without a lot code duplication.
                It will become even verbose if your application has a lot asynchronous calls.
            </p >
            <p>
                Backskin is designed just to address these issues.
            </p>
            <p >Now you don't have to worry about the Router. Backskin takes care of the chores for you and provides you the
                Controllers you have longed. Just define the Controllers and it starts to work automatically. You also get
                the functionality of automatic session checking and event hooks like 'beforeFilter' and 'afterRender'.
                There are also some utilities provided as well.
            </p >
            <p> Backskin doesn't accomplish what Backbone cannot achieve, but it makes many tasks easier by providing
                many conveniences. So it becomes very practical and useful.</p>
        </section >

        <section class="chapter" >
            <h3 >Getting started</h3 >

            <p >Backskin depends on some other libraries. Before importing it, JQuery, Underscore and Backbone.js must also be imported.</p >
            <p >The source code file for Backskin is currently called <a href="https://raw.github.com/chance-an/backskin/master/backbone-mvc.js">backbone-mvc.js</a></p >
<pre class="brush: html">
&lt;!DOCTYPE html&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;script src=&quot;http://code.jquery.com/jquery-1.7.2.min.js&quot; type=&quot;text/javascript&quot; language=&quot;JavaScript&quot; &gt;&lt;/script&gt;
        &lt;script src=&quot;http://underscorejs.org/underscore-min.js&quot; type=&quot;text/javascript&quot; language=&quot;JavaScript&quot; &gt;&lt;/script&gt;
        &lt;script src=&quot;http://backbonejs.org/backbone-min.js&quot; type=&quot;text/javascript&quot; language=&quot;JavaScript&quot; &gt;&lt;/script&gt;
        &lt;script src=&quot;backbone-mvc.js&quot; type=&quot;text/javascript&quot; language=&quot;JavaScript&quot; &gt;&lt;/script&gt;
    &lt;/head&gt;

...
&lt;/html&gt;
</pre >
       <p>Then you can start to define your controllers. It follows the same syntax as you define Model and View. To define a <code>Controller</code>,
           use <code>Backskin.Controler.extend(properties)</code> method :</p>
<pre class="brush: javascript">
    var Controller1 = Backskin.Controller.extend({
        name: 'ctrl1', /* the only mandatory field */

        /**
         * This is a common action method, it is invoked
         * automatically if url matches
         */
        hello: function(){
            alert('Hello world!');
        },

        helloInChinese: function(){
            //you can invoke any method in this controller (including the private methods for sure)
            this._privateMethod();
        },

        /**
         * This function will remain untouched, the router cannot see
         * this method
         */
        _privateMethod: function(){
            alert('你好世界!');
        }
    })
</pre>
        <h5>Notice:</h5>
        <ul>
            <li>You can put the attributes and methods for your <code>Controller</code> in the <code>properties</code> parameter.</li>
            <li>You must at least specify the <code>name</code> attribute, so the router will know what is the controller's name in the url.</li>
            <li>The methods that do not start with an underscore(_) is action methods, and will be mapped by urls. The ones that start with an underscore
                are private methods, which will be disregarded by the router.</li>
        </ul>

        <p>The last step is to create <strong class="blue">Backskin</strong>'s router instance, and start the
            <strong class="red">Backbone</strong>'s <a href="http://backbonejs.org/#History">History</a> component, so the
        routing mechanism will take effect.</p>

<pre class="brush: javascript">

    var router = new Backskin.Router(); //please use the new automatic router
    Backbone.history.start(); //please still call Backbone's facility here

</pre>
        <p>That's all. Give it a try. (Be aware of the URL change in your browser.)</p>

        <p>Trigger <code>hello()</code> : <a href="#ctrl1/hello">#ctrl1/hello</a></p>
        <p>Trigger <code>helloInChinese()</code> : <a href="#ctrl1/helloInChinese">#ctrl1/helloInChinese</a></p>

        <h5>Notice:</h5>
        <ul>
            <li>You only need to define the <code>Controller</code>, you don't even have to instantiate it.</li>
            <li>If you directly visit that URL(with hash), the method will still be invoked.</li>
        </ul>
        </section >

        <section class="chapter" >
            <h3 >Features</h3 >

            <h4>URL-Action Mapping</h4 >
            <p>
                According to Backbone's <a href="http://backbonejs.org/#Router">Router</a> component. The hash
                fragments(#page) or a portion of the static url can be used for routing. It's the same for Backskin's
                routing strategy. In this documentation, we will assume you use the hash fragments way.
            </p>

            <p>
                Like CakePHP, the hash fragments are divided by slashes into <code class="term">controller name</code>,
                <code class="term">method</code> and <code class="term">optional parameters</code> three parts.
            </p>
            <pre>
 URL_TO_ROUTE := CONTROLLER_NAME '/' METHOD_NAME (ADDITIONAL_PARAMETERS)
 ADDITIONAL_PARAMETERS := '/' LITERAL_VALUE (ADDITIONAL_PARAMETERS )
 CONTROLLER_NAME := LITERAL_VALUE
 METHOD_NAME : LITERAL_VALUE
 LITERAL_VALUE: [^/]+
            </pre>

            <h5>Examples:</h5>
            <ul>
                <li>controller1/method1</li>
                <li>my_controller/my-method/happy/birthday</li>
            </ul>

            <p>The optional parameters can be 0 or many, which are also separated by slash(/). No matter how many
                parameters are in the url, they will all be tossed over to the method in the order of appearance.</p>
<pre class="brush: javascript">
Backskin.Controller.extend({
    name: 'my_controller', /* the only mandatory field */

    'my-method': function(how, when){
        var phrase = how + ' ' + (when || 'unknown');
        this._output(phrase);
    },

    _output: function(string){
        $(&#39;#area1&#39;).append($(&#39;&lt;div&gt;&#39; + string + &#39;&lt;/div&gt;&#39;));
    }
})
</pre>
            <p>Try it in action:</p>
            <p id="area1"></p>
            <p>Trigger <code>my-method()</code> with 2 parameters: <br/><a
                    href="#my_controller/my-method/happy/birthday">#my_controller/my-method/happy/birthday</a></p>
            <p>Trigger <code>my-method()</code> with 1 parameter: <br/><a href="#my_controller/my-method/happy">#my_controller/my-method/happy</a></p>

            <p>Private methods do not count. This helps protect your encapsulation.</p>
            <p>Trigger a private method: <a href="#my_controller/_output/really?">my_controller/_output/really?</a></p>

            <h4>Asynchronous Call</h4 >
            <p>The <a href="http://backbonejs.org/#Router-navigate"><code class="term">navigate()</code></a> method
                of  Backbone's <a href="http://backbonejs.org/#Router">Router</a> component can trigger url routing
                programmatically. Backskin further enhances this method, and the method now returns a
                <a href="http://api.jquery.com/category/deferred-object/">JQuery
                Deferred object</a>. You can use it to make sure the action method has finished. This is useful when
                it contains asynchronous calls. </p>

            <p>See the following example:</p>
<pre class="brush: javascript">
var AsynchronousController = Backskin.Controller.extend({
    name: 'asynchronous', /* the only mandatory field */

    'method': function(){
        var deferred = new $.Deferred();

        var colors = ['red', 'orange', 'yellow', 'green', 'cyan', 'blue', 'purple'];
        var index = 0;

        var instance = this;
        (function op(){
            if(index < colors.length){
                instance._changeColor(colors[index++]);
                setTimeout(op, 567);
            }else{
                deferred.resolve();
            }
        })();
        return deferred;
    },

    _changeColor: function(color){
        $('#area2').css('background-color', color);
    }
});

function procedure1(){
    var r = router.navigate('asynchronous/method', {trigger:true, replace: false});
    r.done(function(){
        $('#area2').html('Nice I change to white!');
        (new AsynchronousController())._changeColor('white');
    });
};
</pre>
            <p id="area2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</p>

            <p>See it in action:</p>
            <p>Trigger the procedure1() method: <br/><a href="javascript:procedure1();">Click here to trigger
                procedure1()</a></p>

            <h4>Event Hooks</h4>
            <p>Like CakePHP, before and after invoking an action method, <code>beforeFilter</code> and
                <code>afterRender</code> event handlers can also be set.</p>
            <p>For example:</p>
 <pre class="brush: javascript">
 Backskin.Controller.extend({
    name: &#39;event_hooks&#39;, /* the only mandatory field */

    beforeFilter: function(){
        this._report(&#39;beforeFilter invoked&#39;);
    },

    method1: function(){
        this._report(&#39;method1 invoked&#39;);
    },

    method2: function(){
        var index = 0;
        var instance = this;
        var deferred = new $.Deferred();
        (function op(){
            if(index ++ &lt; 5){
                instance._report(index);
                setTimeout(op, 345);
            }else{
                deferred.resolve();
            }
        })();
        return deferred;
    },

    afterRender: function(){
        this._report(&#39;afterRender invoked&#39;);
    },

    _report: function(text){
        $(&#39;#area3&#39;).append(&#39;&lt;div&gt;&#39; + text + &#39;&lt;/div&gt;&#39;);
    }
});
 </pre>
            <p id="area3"></p>
            <p>Trigger <code>mehtod1()</code> <a
                    href="#event_hooks/method1">#event_hooks/method1</a></p>

            <p>If your action method return a Deferred object, then the <code>afterRender</code> event hook will be
                deferred in execution</p>
            <p>Trigger <code>method2()</code> <a
                    href="#event_hooks/method2">#event_hooks/method2</a></p>

            <h5>Rules for the call chain of <code>beforeFilter</code>, <code>afterRender</code> and the action method </h5>
            <ul>
                <li>All of the <code>beforeFilter</code>, <code>afterRender</code> and the action method can opt to return a Deferred object.
                If either of them does, then its successor will wait on the predecessor's Deferred object.
                Unless the Deferred object is resolved, all the subsequent methods on the chain won't be executed.</li>
                <li>If a predecessor return a non-deferred value, and the value can be evaluated to true, the successor will run as it does normally,
                or otherwise the call chain will be interrupted.</li>
                <li>
                    If a predecessor doesn't return a value, the successor will run as it does normally.
                </li>
                <li>If at any point, the call chain is interrupted, either by a rejected object or a false value, and the
                    <code class="term">navigate()</code> method is used to issue the call, the returned Deferred object from
                    <code class="term">navigate()</code> will be rejected.</li>
            </ul>

            <p>See the following example:</p>
<div id="area4">
<pre class="brush: javascript">
var EventHooks1= Backskin.Controller.extend({
    name: &#39;event_hooks1&#39;, /* the only mandatory field */

    beforeFilter: function(){
        this._report(&#39;beforeFilter invoked&#39;);
        //always successful (can also be achieved if return nothing)
        return true;
    },

    method1: function(){
        this._report(&#39;method1 invoked&#39;);
        var deferred = new $.Deferred();

        var colors = [&#39;red&#39;, &#39;orange&#39;, &#39;yellow&#39;, &#39;green&#39;, &#39;cyan&#39;, &#39;blue&#39;, &#39;purple&#39;];
        var index = 0;

        var instance = this;
        (function op(){
            if(index &lt; colors.length){
                instance._changeColor(colors[index++]);
                setTimeout(op, 234);
            }else{
                deferred.resolve();
            }
        })();
        return deferred;
    },

    method2: function(){
        this._changeColor(&#39;MidnightBlue&#39;);
        this._report(&#39;method2 invoked&#39;);
        this._report(&#39;afterRender won\&#39;t be executed&#39;);
        return false; // a false value, the subsequent method gets no chance to be executed
    },

    method3: function(){
        this._changeColor(&#39;Indigo&#39;);
        this._report(&#39;method3 invoked&#39;);
        this._report(&#39;afterRender will be executed&#39;);
        // return nothing has the same effect as returning true
    },

    afterRender: function(){
        // reject, so the call chain will eventually fail even though the
        // main action method is executed
        this._report(&#39;afterRender invoked&#39;);
        return (new $.Deferred()).reject();
    },

    _report: function(text){
        $(&#39;#area4&#39;).append(&#39;&lt;div&gt;&#39; + text + &#39;&lt;/div&gt;&#39;);
    },

    _changeColor: function(color){
        $(&#39;#area4&#39;).css(&#39;backgroundColor&#39;, color);
    }
});

window[&#39;procedure2&#39;] = function(){
    var r = router.navigate(&#39;event_hooks1/method2&#39;, {trigger:true, replace: false});
    r.done(function(){
        (new EventHooks1())._report(&#39;procedure2 successful&#39;);
    }).fail(function(){
        (new EventHooks1())._report(&#39;procedure2 failed&#39;);
    });
};

window[&#39;procedure3&#39;] = function(){
    var r = router.navigate(&#39;event_hooks1/method3&#39;, {trigger:true, replace: false});
    r.done(function(){
        (new EventHooks1())._report(&#39;procedure3 successful&#39;);
    }).fail(function(){
        (new EventHooks1())._report(&#39;procedure3 failed&#39;);
    });
};
</pre>
</div>
            <p>Trigger <code>method1()</code> <a href="#event_hooks1/method1">#event_hooks1/method1</a></p>
            <p>Trigger <code>procedure2()</code> <a href="javascript:procedure2()">procedure2()</a></p>
            <p>Trigger <code>procedure3()</code> <a href="javascript:procedure3()">procedure3()</a></p>

            <p>When used with Deferred objects, the event hooks can be useful if you want to prepare templates for your actions to render views,
                or select the corresponding navigation entry for all the actions in the controller after their execution.</p>

            <h4>Session Checking</h4>

            <h4>Controllers Are Singletons</h4 >

            <h4>Controller Inheritance</h4 >
        </section >


        <!--<h3 >Authors and Contributors</h3 >-->

        <!--<p >You can <a href="https://github.com/blog/821" class="user-mention" >@mention</a > a GitHub username to-->
            <!--generate-->
            <!--a link to their profile. The resulting <code >&lt;a&gt;</code > element will link to the contributor's-->
            <!--GitHub-->
            <!--Profile. For example: In 2007, Chris Wanstrath (<a href="https://github.com/defunkt" class="user-mention" >@defunkt</a >),-->
            <!--PJ Hyett (<a href="https://github.com/pjhyett" class="user-mention" >@pjhyett</a >), and Tom Preston-Werner-->
            <!--(<a href="https://github.com/mojombo" class="user-mention" >@mojombo</a >) founded GitHub.-->
        <!--</p >-->

        <h3 >Support or Contact</h3 >
        <p>Have questions or suggestions? Please contact <a href="https://github.com/chance-an">Changsi An</a> by me@anchangsi.com .</p>
        <!--<p >Having trouble with Pages? Check out the documentation at <a href="http://help.github.com/pages" >http://help.github.com/pages</a >-->
            <!--or contact <a href="mailto:support@github.com" >support@github.com</a > and we’ll help you sort it out.-->
        <!--</p >-->
    </section >
</div >


</body >
</html >