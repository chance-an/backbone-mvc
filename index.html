<!DOCTYPE html>
<html >
<head >
    <meta charset='utf-8' >

    <link rel="stylesheet" type="text/css" href="stylesheets/pygment_trac.css" media="screen" />

    <script type="text/javascript" language="JavaScript" src="http://code.jquery.com/jquery-1.7.2.min.js"></script>
    <script type="text/javascript" language="JavaScript" src="http://underscorejs.org/underscore-min.js"></script>
    <script type="text/javascript" language="JavaScript" src="http://backbonejs.org/backbone-min.js"></script>
    <script type="text/javascript" src="javascripts/SyntaxHighlighter/XRegExp.js"></script> <!-- XRegExp is bundled with the final shCore.js during build -->
    <script type="text/javascript" src="javascripts/SyntaxHighlighter/shCore.js"></script>
    <script type="text/javascript" src="javascripts/SyntaxHighlighter/shAutoloader.js"></script>
    <script src="javascripts/backbone-mvc.js" type="text/javascript" language="JavaScript"></script>
    <script src="javascripts/bootstrap.min.js" type="text/javascript" language="JavaScript"></script>
    <script src="javascripts/main.js" type="text/javascript" language="JavaScript"></script>

    <script type="text/javascript">

        var _gaq = _gaq || [];
        _gaq.push(['_setAccount', 'UA-33780487-1']);
        _gaq.push(['_trackPageview']);

        (function() {
            var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
            ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
            var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
        })();

    </script>

    <link type="text/css" rel="stylesheet" href="stylesheets/SyntaxHighlighter/shCoreRDark.css"/>
    <link type="text/css" rel="Stylesheet" href="stylesheets/SyntaxHighlighter/shThemeRDark.css" />
    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen" />
    <link rel="stylesheet" type="text/css" href="stylesheets/bootstrap.min.css" media="screen" />
    <title >BackboneMVC : Add Controllers to Backbone.js</title >
</head >

<!--<body data-spy="scroll" >-->
<body >

<header >
    <div id="title" class="container" >
        <h1 >BackboneMVC</h1 >
        <h2 ></h2 >

        <section id="downloads" >
            <a href="https://raw.github.com/chance-an/backbone-mvc/master/backbone-mvc.js" class="btn" >Download
                backbone-mvc.js</a >
            <a href="https://github.com/chance-an/backbone-mvc" class="btn btn-github" ><span class="icon" ></span >View on
                GitHub</a >
        </section >
    </div >
    <div id="primary_nav" >
        <div class="subnav">
            <ul class="nav nav-pills">
                <li class=""><a href="#title">Title</a></li>
                <li class=""><a href="#introduction">Introduction</a></li>
                <li class=""><a href="#getting-started">Getting started</a></li>
                <li class=""><a href="#features">Features</a></li>
                <li class=""><a href="#support-or-contact">Support or Contact</a></li>
            </ul>
        </div>
    </div>
    <div id="sidebar">
        <ul class="nav nav-tabs nav-stacked">
            <li class="nav-header">Features:</li>
            <li class="features-item"><a >URL-Action&nbsp;Mapping</a></li>
            <li class="features-item"><a >Asynchronous&nbsp;Call</a></li>
            <li class="features-item"><a >Event Hooks</a></li>
            <li class="features-item"><a >Session Checking</a></li>
            <li class="features-item"><a >Controllers&nbsp;Are<br/>Singletons</a></li>
            <li class="features-item"><a >Controller<br/>Inheritance</a></li>
        </ul>
    </div>
</header >

<div class="container" >
    <section id="main_content" >
        <section >
            <p >BackboneMVC adds the missing Controller components into your project if you also use
                <a href="http://github.com/documentcloud/backbone/" >Backbone.js</a >, so now you have a complete MVC
                framework. Like
                <a href="http://cakephp.org/" >CakePHP</a >, it automatically routes your urls to the correct controller
                and its actions, but it is a framework for the web front end.
            </p >
        </section >

        <section id="introduction" class="chapter" >
            <h3 >Introduction</h3 >

            <p >Backbone.js does an excellent job of keeping the HTML UI and your Javascript business in sync.
                However the difficulties we face when
                we build Javascript web applications are not completely addressed by Backbone.js . Sometimes the difficulty of
                efficiently organizing the Javascript logic itself is prominent. Using urls to lead the execution of the Javascript logic
                is a good way to implement your business logic. The browsers' assumption of a traditional server/client
                model is not compromised, so the browsers' basic functions can be preserved. It also helps resume the correct
                stage in your business flow from a stateless page.
            <p>Backbone.js provides
                <a href="http://backbonejs.org/#Router">Router</a> component to map an url to a function.
                It becomes cumbersome when the application is divided into many modules and there are many operations to
                be mapped for different urls. Besides, due to the limitations of the language itself, it is not easy to
                share common processes(like pre-processors and post-processors) among those operations without a lot code duplication.
                It will become even verbose if your application has a lot asynchronous calls.
            </p >
            <p>
                BackboneMVC is designed just to address these issues.
            </p>
            <p >Now you don't have to worry about the Router. BackboneMVC takes care of the chores for you and provides you the
                Controllers you have longed. Just define the Controllers and it starts to work automatically. You also get
                the functionality of automatic session checking and event hooks like 'beforeFilter' and 'afterRender'.
                There are also some utilities provided as well.
            </p >
            <p> BackboneMVC doesn't accomplish what Backbone cannot achieve, but it makes many tasks easier by providing
                many conveniences. So it becomes very practical and useful.</p>
        </section >

        <section id="getting-started" class="chapter" >
            <h3 >Getting started</h3 >

            <p >BackboneMVC depends on some other libraries. Before importing it, JQuery, Underscore and Backbone.js must also be imported.</p >
            <p >The source code file for BackboneMVC is currently called <a href="https://raw.github.com/chance-an/BackboneMVC/master/backbone-mvc.js">backbone-mvc.js</a></p >
<pre class="brush: html">
&lt;!DOCTYPE html&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;script src=&quot;http://code.jquery.com/jquery-1.7.2.min.js&quot; type=&quot;text/javascript&quot; language=&quot;JavaScript&quot; &gt;&lt;/script&gt;
        &lt;script src=&quot;http://underscorejs.org/underscore-min.js&quot; type=&quot;text/javascript&quot; language=&quot;JavaScript&quot; &gt;&lt;/script&gt;
        &lt;script src=&quot;http://backbonejs.org/backbone-min.js&quot; type=&quot;text/javascript&quot; language=&quot;JavaScript&quot; &gt;&lt;/script&gt;
        &lt;script src=&quot;backbone-mvc.js&quot; type=&quot;text/javascript&quot; language=&quot;JavaScript&quot; &gt;&lt;/script&gt;
    &lt;/head&gt;

...
&lt;/html&gt;
</pre >
       <p>Then you can start to define your controllers. It follows the same syntax as you define Model and View. To define a <code>Controller</code>,
           use <code>BackboneMVC.Controler.extend(properties)</code> method :</p>
<pre class="brush: javascript">
    var Controller1 = BackboneMVC.Controller.extend({
        name: 'ctrl1', /* the only mandatory field */

        /**
         * This is a common action method, it is invoked
         * automatically if url matches
         */
        hello: function(){
            alert('Hello world!');
        },

        helloInChinese: function(){
            //you can invoke any method in this controller (including the private methods for sure)
            this._privateMethod();
        },

        /**
         * This function will remain untouched, the router cannot see
         * this method
         */
        _privateMethod: function(){
            alert('你好世界!');
        }
    })
</pre>
        <h5>Notice:</h5>
        <ul>
            <li>You can put the attributes and methods for your <code>Controller</code> in the <code>properties</code> parameter.</li>
            <li>You must at least specify the <code>name</code> attribute, so the router will know what is the controller's name in the url.</li>
            <li>The methods that do not start with an underscore(_) is action methods, and will be mapped by urls. The ones that start with an underscore
                are private methods, which will be disregarded by the router.</li>
        </ul>

        <p>The last step is to create <strong class="blue">BackboneMVC</strong>'s router instance, and start the
            <strong class="red">Backbone</strong>'s <a href="http://backbonejs.org/#History">History</a> component, so the
        routing mechanism will take effect.</p>

<pre class="brush: javascript">

    var router = new BackboneMVC.Router(); //please use the new automatic router
    Backbone.history.start(); //please still call Backbone's facility here

</pre>
        <p>That's all. Give it a try. (Be aware of the URL change in your browser.)</p>

        <p>Trigger <code>hello()</code> : <a href="#ctrl1/hello">#ctrl1/hello</a></p>
        <p>Trigger <code>helloInChinese()</code> : <a href="#ctrl1/helloInChinese">#ctrl1/helloInChinese</a></p>

        <h5>Notice:</h5>
        <ul>
            <li>You only need to define the <code>Controller</code>, you don't even have to instantiate it.</li>
            <li>If you directly visit that URL(with hash), the method will still be invoked.</li>
        </ul>
        </section >

        <section id="features" class="chapter" >
            <h3 >Features</h3 >

            <h4>URL-Action Mapping</h4 >
            <p>
                According to Backbone's <a href="http://backbonejs.org/#Router">Router</a> component. The hash
                fragments(#page) or a portion of the static url can be used for routing. It's the same for BackboneMVC's
                routing strategy. In this documentation, we will assume you use the hash fragments way.
            </p>

            <p>
                Like CakePHP, the hash fragments are divided by slashes into <code class="term">controller name</code>,
                <code class="term">method</code> and <code class="term">optional parameters</code> three parts.
            </p>
            <pre>
 URL_TO_ROUTE := CONTROLLER_NAME '/' METHOD_NAME (ADDITIONAL_PARAMETERS)
 ADDITIONAL_PARAMETERS := '/' LITERAL_VALUE (ADDITIONAL_PARAMETERS )
 CONTROLLER_NAME := LITERAL_VALUE
 METHOD_NAME : LITERAL_VALUE
 LITERAL_VALUE: [^/]+
            </pre>

            <h5>Examples:</h5>
            <ul>
                <li>controller1/method1</li>
                <li>my_controller/my-method/happy/birthday</li>
            </ul>

            <p>The optional parameters can be 0 or many, which are also separated by slash(/). No matter how many
                parameters are in the url, they will all be tossed over to the method in the order of appearance.</p>
<pre class="brush: javascript">
BackboneMVC.Controller.extend({
    name: 'my_controller', /* the only mandatory field */

    'my-method': function(how, when){
        var phrase = how + ' ' + (when || 'unknown');
        this._output(phrase);
    },

    _output: function(string){
        $(&#39;#area1&#39;).append($(&#39;&lt;div&gt;&#39; + string + &#39;&lt;/div&gt;&#39;));
    }
})
</pre>
            <p>Try it in action:</p>
            <p id="area1"></p>
            <p>Trigger <code>my-method()</code> with 2 parameters: <br/><a
                    href="#my_controller/my-method/happy/birthday">#my_controller/my-method/happy/birthday</a></p>
            <p>Trigger <code>my-method()</code> with 1 parameter: <br/><a href="#my_controller/my-method/happy">#my_controller/my-method/happy</a></p>

            <p>Private methods do not count. This helps protect your encapsulation.</p>
            <p>Trigger a private method: <a href="#my_controller/_output/really?">my_controller/_output/really?</a></p>

            <h4>Asynchronous Call</h4 >
            <p>The <a href="http://backbonejs.org/#Router-navigate"><code class="term">navigate()</code></a> method
                of  Backbone's <a href="http://backbonejs.org/#Router">Router</a> component can trigger url routing
                programmatically. BackboneMVC further enhances this method, and the method now returns a
                <a href="http://api.jquery.com/category/deferred-object/">JQuery
                Deferred object</a>. You can use it to make sure the action method has finished. This is useful when
                it contains asynchronous calls. </p>

            <p>See the following example:</p>
<pre class="brush: javascript">
var AsynchronousController = BackboneMVC.Controller.extend({
    name: 'asynchronous', /* the only mandatory field */

    'method': function(){
        var deferred = new $.Deferred();

        var colors = ['red', 'orange', 'yellow', 'green', 'cyan', 'blue', 'purple'];
        var index = 0;

        var instance = this;
        (function op(){
            if(index < colors.length){
                instance._changeColor(colors[index++]);
                setTimeout(op, 567);
            }else{
                deferred.resolve();
            }
        })();
        return deferred;
    },

    _changeColor: function(color){
        $('#area2').css('background-color', color);
    }
});

function procedure1(){
    var r = router.navigate('asynchronous/method', {trigger:true, replace: false});
    r.done(function(){
        $('#area2').html('Nice I change to white!');
        (new AsynchronousController())._changeColor('white');
    });
};
</pre>
            <p id="area2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</p>

            <p>See it in action:</p>
            <p>Trigger the procedure1() method: <br/><a href="javascript:procedure1();">Click here to trigger
                procedure1()</a></p>

            <h4>Event Hooks</h4>
            <p>Like CakePHP, before and after invoking an action method, <code>beforeFilter</code> and
                <code>afterRender</code> event handlers can also be set.</p>
            <p>For example:</p>
 <pre class="brush: javascript">
 BackboneMVC.Controller.extend({
    name: &#39;event_hooks&#39;, /* the only mandatory field */

    beforeFilter: function(){
        this._report(&#39;beforeFilter invoked&#39;);
    },

    method1: function(){
        this._report(&#39;method1 invoked&#39;);
    },

    method2: function(){
        var index = 0;
        var instance = this;
        var deferred = new $.Deferred();
        (function op(){
            if(index ++ &lt; 5){
                instance._report(index);
                setTimeout(op, 345);
            }else{
                deferred.resolve();
            }
        })();
        return deferred;
    },

    afterRender: function(){
        this._report(&#39;afterRender invoked&#39;);
    },

    _report: function(text){
        $(&#39;#area3&#39;).append(&#39;&lt;div&gt;&#39; + text + &#39;&lt;/div&gt;&#39;);
    }
});
 </pre>
            <p id="area3"></p>
            <p>Trigger <code>mehtod1()</code> <a
                    href="#event_hooks/method1">#event_hooks/method1</a></p>

            <p>If your action method return a Deferred object, then the <code>afterRender</code> event hook will be
                deferred in execution</p>
            <p>Trigger <code>method2()</code> <a
                    href="#event_hooks/method2">#event_hooks/method2</a></p>

            <h5>Rules for the call chain of <code>beforeFilter</code>, <code>afterRender</code> and the action method </h5>
            <ul>
                <li>All of the <code>beforeFilter</code>, <code>afterRender</code> and the action method can opt to return a Deferred object.
                If either of them does, then its successor will wait on the predecessor's Deferred object.
                Unless the Deferred object is resolved, all the subsequent methods on the chain won't be executed.</li>
                <li>If a predecessor return a non-deferred value, and the value can be evaluated to true, the successor will run as it does normally,
                or otherwise the call chain will be interrupted.</li>
                <li>
                    If a predecessor doesn't return a value, the successor will run as it does normally.
                </li>
                <li>If at any point, the call chain is interrupted, either by a rejected object or a false value, and the
                    <code class="term">navigate()</code> method is used to issue the call, the returned Deferred object from
                    <code class="term">navigate()</code> will be rejected.</li>
            </ul>

            <p>See the following example:</p>
<div id="area4">
<pre class="brush: javascript">
var EventHooks1= BackboneMVC.Controller.extend({
    name: &#39;event_hooks1&#39;, /* the only mandatory field */

    beforeFilter: function(){
        this._report(&#39;beforeFilter invoked&#39;);
        //always successful (can also be achieved if return nothing)
        return true;
    },

    method1: function(){
        this._report(&#39;method1 invoked&#39;);
        var deferred = new $.Deferred();

        var colors = [&#39;red&#39;, &#39;orange&#39;, &#39;yellow&#39;, &#39;green&#39;, &#39;cyan&#39;, &#39;blue&#39;, &#39;purple&#39;];
        var index = 0;

        var instance = this;
        (function op(){
            if(index &lt; colors.length){
                instance._changeColor(colors[index++]);
                setTimeout(op, 234);
            }else{
                deferred.resolve();
            }
        })();
        return deferred;
    },

    method2: function(){
        this._changeColor(&#39;MidnightBlue&#39;);
        this._report(&#39;method2 invoked&#39;);
        this._report(&#39;afterRender won\&#39;t be executed&#39;);
        return false; // a false value, the subsequent method gets no chance to be executed
    },

    method3: function(){
        this._changeColor(&#39;Indigo&#39;);
        this._report(&#39;method3 invoked&#39;);
        this._report(&#39;afterRender will be executed&#39;);
        // return nothing has the same effect as returning true
    },

    afterRender: function(){
        // reject, so the call chain will eventually fail even though the
        // main action method is executed
        this._report(&#39;afterRender invoked&#39;);
        return (new $.Deferred()).reject();
    },

    _report: function(text){
        $(&#39;#area4&#39;).append(&#39;&lt;div&gt;&#39; + text + &#39;&lt;/div&gt;&#39;);
    },

    _changeColor: function(color){
        $(&#39;#area4&#39;).css(&#39;backgroundColor&#39;, color);
    }
});

window[&#39;procedure2&#39;] = function(){
    var r = router.navigate(&#39;event_hooks1/method2&#39;, {trigger:true, replace: false});
    r.done(function(){
        (new EventHooks1())._report(&#39;procedure2 successful&#39;);
    }).fail(function(){
        (new EventHooks1())._report(&#39;procedure2 failed&#39;);
    });
};

window[&#39;procedure3&#39;] = function(){
    var r = router.navigate(&#39;event_hooks1/method3&#39;, {trigger:true, replace: false});
    r.done(function(){
        (new EventHooks1())._report(&#39;procedure3 successful&#39;);
    }).fail(function(){
        (new EventHooks1())._report(&#39;procedure3 failed&#39;);
    });
};
</pre>
</div>
            <p>Trigger <code>method1()</code> <a href="#event_hooks1/method1">#event_hooks1/method1</a></p>
            <p>Trigger <code>procedure2()</code> <a href="javascript:procedure2()">procedure2()</a></p>
            <p>Trigger <code>procedure3()</code> <a href="javascript:procedure3()">procedure3()</a></p>

            <p>When used with Deferred objects, the event hooks can be useful if you want to prepare templates for your
                actions to render views, or select the corresponding navigation entry for all the actions in the
                controller after their execution.</p>

            <h4>Session Checking</h4>

            <p>Similar to <code class="term">beforeFilter</code> and <code class="term">afterRender</code> methods, you can
            also define a <code class="term">checkSession</code> method. Then all action methods with a prefix of 'user_' in their
            names, will be invoked only after the <code class="term">checkSession</code> is called.</p>

            <p>If <code class="term">checkSession</code> returns false or a Deferred object, which will later be rejected,
            the action methods will not be invoked.</p>

            <p>See example:</p>
<pre class="brush: javascript">
BackboneMVC.Controller.extend({
    name: &#39;session_enabled&#39;, /* the only mandatory field */

    beforeFilter: function(){
        this._report(&#39;beforeFilter invoked&#39;);
        return true;
    },

    checkSession: function(){
        this._report(&#39;checkSession invoked&#39;);

        var deferred = new $.Deferred();

        var instance = this;
        setTimeout(function(){
            instance._report(&#39;session is valid!&#39;);
            deferred.resolve();
        }, 2000);
        return deferred;
    },

    user_method1: function(){
        this._report(&#39;method1 invoked&#39;);
    },

    user_method2: function(){
        this._report(&#39;secure method2 invoked&#39;);
        this._changeColor(&#39;green&#39;);
    },

    method2: function(){
        this._report(&#39;normal method2 invoked&#39;);
        this._changeColor(&#39;DimGray&#39;);
    },

    _report: function(text){
        $(&#39;#area5&#39;).append(&#39;&lt;div&gt;&#39; + text + &#39;&lt;/div&gt;&#39;);
    },

    _changeColor: function(color){
        $(&#39;#area5&#39;).css(&#39;backgroundColor&#39;, color);
    }
});
</pre>
            <p id="area5"></p>
            <p>Trigger <code>user_method1()</code> <a href="#session_enabled/user_method1">#session_enabled/user_method1</a></p>

            <p>You can even omit the 'user_' prefix:</p>
            <p>Trigger <code>method1()</code> <a href="#session_enabled/method1">#session_enabled/method1</a></p>

            <p>However if the method without the 'user_' prefix is already defined, then the shortcut will not overwrite the existing one,
            see example:</p>

            <p>Trigger <code>user_method2()</code> <a href="#session_enabled/user_method2">#session_enabled/user_method2</a></p>
            <p>Trigger <code>method2()</code> <a href="#session_enabled/method2">#session_enabled/method2</a></p>

            <p>As you can see, the <code class="term">checkSession</code> is invoked after <code class="term">beforeFilter</code>, but before
            the action method.</p>


            <h4>Controllers Are Singletons</h4 >

            <p>Controllers are all singletons. So no matter when and where you instantiate a controller, the instance always keeps the same state.</p>
            <div id="area6">
<pre class="brush: javascript">
var Singleton = BackboneMVC.Controller.extend({
    name: 'singleton', /* the only mandatory field */
    value: 0,

    method: function(){
        this._report(this.value++);
    },

    _report: function(text){
        $('#area6').append('<div>' + text + '</div>');
    }
});

window['procedure4'] = function(){
    (new Singleton()).method();
};
</pre>
            </div>
            <p>Trigger <code>method()</code> <a href="#singleton/method">#singleton/method</a></p>
            <p>Call <code>procedure4()</code> <a href="javascript:procedure4()">procedure4()</a></p>
            <h4>Controller Inheritance</h4 >
            <p><code>Controller.extend()</code> can be used to do class inheritance. So your controllers are able to share
            functionality from their parent controller.</p>
            <p>See example:</p>
            <div id="area7">
<pre class="brush: javascript">
var Parent = BackboneMVC.Controller.extend({
    name: &#39;parent&#39;, /* the only mandatory field, even though the parent is not planned to be used,
    it still need to be granted a name. */

    method: function(){
        this._report(&#39;Parent method invoked&#39;);
        this._changeColor(&#39;#141F2E&#39;);
    },

    _report: function(text){
        $(&#39;#area7&#39;).append(&#39;&lt;div&gt;&#39; + text + &#39;&lt;/div&gt;&#39;);
    },

    _changeColor: function(color){
        $(&#39;#area7&#39;).css(&#39;backgroundColor&#39;, color);
    }
});

var Child1 = Parent.extend({
    name: &#39;child1&#39;, /* the only mandatory field */

    method: function(){
        this._report(&#39;Child1 method invoked&#39;);
        this._changeColor(&#39;green&#39;);
    }
});

var Child2 = Parent.extend({
    name: &#39;child2&#39; /* the only mandatory field */

    //this controller doesn&#39;t implement anything, so its parent&#39;s methods will be passed over.
});
</pre>
            </div>
            <p>Trigger <code>Child1::method()</code> <a href="#child1/method">#child1/method</a></p>
            <p>Trigger <code>Child2::method()</code> <a href="#child2/method">#child2/method</a></p>
        </section>


        <section id="support-or-contact" class="chapter">
            <h3 >Support or Contact</h3 >
            <p>Have questions or suggestions? Please contact <a href="https://github.com/chance-an">Changsi An</a> by me@anchangsi.com .</p>
            <p>Copyright 2012 Changsi An</p>
        </section>
    </section >
</div >


</body >
</html >